TODO:
0.1:
+ + calculate multiple routes and select the shortest : not optimized
+ add 'waypoints'
+ save layout to json
+  + create route description from path. ex: turn right, move straight ahead 4 squares, turn left... : temporary solution by storing direction to obj.directions
+ do not add start position to final solution before return;
+ set predefined directions to be called in recursive function before randomization
+ break from loop if path length is equal to actual distance
+ return the difference between the path length and the straight course length
+ learn from each iteration: if path to waypoint is bigger - return null - iterate until path is found
+ store the path including steps taken in solutions object
+ refactor ui clicking logic
+ register each turn event and store in object. send out 'sonar' on each event meaning a for loop searching left and right on each step in the new direction for the target element.
+ write logic that checks if direction is the same for a while to minimize recursive function calls â€“ or if same direction leads to distination
+ identify fork squares and make sure that each path takes a different route and doesn't randomize
+ identify fork squares and use amount as a basis for determining functionCounter and frequencyCut
+ write logic prevent stack overflow
+ store the the 4 directions in an object with an attached property indicting direction. Prevent uturn movements.
+ define movement patters for open space





Done:
+ create ids for grid items with javascript
+ set start and end by clicking
+ paint path on mousedown
+ evaluate length of path on each recursion and return null if path length + actual direct length to target is greater than previous solution.
+ store solutions not null in array. if path length of the last n number of solutions is identical, break loop.
+ fix solution path painted red
